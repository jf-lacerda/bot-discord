"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.toCSS = exports.mix = exports.evolve = exports.setAlpha = exports.alpha = exports.rotateHue = exports.fromLCh = exports.fromLab = exports.fromXYZ = exports.fromHSVA = exports.fromRGBA = exports.hsl = exports.hsla = void 0;
/**
 * @since 0.1.5
 */
var function_1 = require("fp-ts/function");
var struct = __importStar(require("fp-ts/struct"));
var Hue = __importStar(require("./Hue"));
var UnitInterval_1 = require("./UnitInterval");
var RGBA = __importStar(require("./RGBA"));
var XYZ = __importStar(require("./XYZ"));
var Lab = __importStar(require("./Lab"));
var math_1 = require("./math");
/**
 * @category constructors
 * @since 0.1.5
 */
var hsla = function (h, s, l, a) { return ({
    h: Hue.hue(h),
    s: UnitInterval_1.unitInterval(s),
    l: UnitInterval_1.unitInterval(l),
    a: UnitInterval_1.unitInterval(a)
}); };
exports.hsla = hsla;
/**
 * @category constructors
 * @since 0.1.5
 */
var hsl = function (h, s, l) { return exports.hsla(h, s, l, 1.0); };
exports.hsl = hsl;
/**
 * @category constructors
 * @since 0.1.5
 */
var fromRGBA = function (rgba) {
    var maxChroma = RGBA.maxChroma(rgba);
    var minChroma = RGBA.minChroma(rgba);
    var chroma = RGBA.chroma(rgba);
    var hue = Hue.fromRGBA(rgba);
    var lightness = (maxChroma + minChroma) / (255.0 * 2.0);
    var saturation = chroma === 0 ? 0 : chroma / 255 / (1.0 - Math.abs(2.0 * lightness - 1.0));
    return exports.hsla(hue, saturation, lightness, rgba.a);
};
exports.fromRGBA = fromRGBA;
/**
 * @category constructors
 * @since 0.1.5
 */
var fromHSVA = function (_a) {
    var h = _a.h, s = _a.s, v = _a.v, a = _a.a;
    var _b = function_1.pipe((2.0 - s) * v, function (tmp) { return ({
        saturation: (s * v) / (tmp < 1.0 ? tmp : 2.0 - tmp),
        lightness: tmp / 2.0
    }); }), saturation = _b.saturation, lightness = _b.lightness;
    if (v === 0) {
        return exports.hsla(h, s / (2.0 - s), 0.0, a);
    }
    if (s === 0 && v === 1.0) {
        return exports.hsla(h, 0.0, 1.0, a);
    }
    return exports.hsla(h, saturation, lightness, a);
};
exports.fromHSVA = fromHSVA;
/**
 * @category constructors
 * @since 0.1.5
 */
exports.fromXYZ = function_1.flow(RGBA.fromXYZ, exports.fromRGBA);
/**
 * @category constructors
 * @since 0.1.5
 */
exports.fromLab = function_1.flow(XYZ.fromLab, exports.fromXYZ);
/**
 * @category constructors
 * @since 0.1.5
 */
exports.fromLCh = function_1.flow(Lab.fromLCh, exports.fromLab);
/**
 * Rotate the hue by a certain angle (in degrees).
 *
 * @since 0.1.5
 */
var rotateHue = function (angle) {
    return function (_a) {
        var h = _a.h, s = _a.s, l = _a.l, a = _a.a;
        return exports.hsla(h + angle, s, l, a);
    };
};
exports.rotateHue = rotateHue;
/**
 * get the alpha channel
 *
 * @since 0.1.7
 */
var alpha = function (_a) {
    var a = _a.a;
    return a;
};
exports.alpha = alpha;
/**
 * set the alpha channel
 *
 * @since 0.1.7
 */
var setAlpha = function (a) {
    return function (_a) {
        var h = _a.h, s = _a.s, l = _a.l;
        return exports.hsla(h, s, l, a);
    };
};
exports.setAlpha = setAlpha;
/**
 * @since 0.1.5
 */
var evolve = function (t) { return function (c) {
    return function_1.pipe(c, struct.evolve(t), function (_a) {
        var h = _a.h, s = _a.s, l = _a.l, a = _a.a;
        return exports.hsla(h, s, l, a);
    });
}; };
exports.evolve = evolve;
/**
 * @since 0.1.5
 */
var mix = function (ratio) {
    return function (a) {
        return function (b) {
            var i = math_1.interpolate(ratio);
            var ia = math_1.interpolateAngle(ratio);
            return function_1.pipe(b, exports.evolve({
                h: ia(a.h),
                s: i(a.s),
                l: i(a.l),
                a: i(a.a)
            }));
        };
    };
};
exports.mix = mix;
/**
 * A CSS representation of the color in the form `hsl(..)` or `hsla(...)`.
 *
 * @since 0.1.5
 * @category destructors
 */
var toCSS = function (_a) {
    var h = _a.h, s = _a.s, l = _a.l, a = _a.a;
    var p = function (n) {
        return function_1.pipe(Math.round(100.0 * (n * 100.0)) / 100.0, function (n) { return n + "%"; });
    };
    var saturation = p(s);
    var lightness = p(l);
    return a == 1.0
        ? "hsl(" + h + ", " + saturation + ", " + lightness + ")"
        : "hsla(" + h + ", " + saturation + ", " + lightness + ", " + a + ")";
};
exports.toCSS = toCSS;
//# sourceMappingURL=HSLA.js.map