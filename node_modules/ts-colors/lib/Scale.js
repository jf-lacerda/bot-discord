"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.cssColorStops = exports.minColorStops = exports.cool = exports.hot = exports.yellowToRed = exports.blueToRed = exports.spectrum = exports.modify = exports.modifyColorStops = exports.sampleColors = exports.makeColors = exports.sample = exports.simpleSampler = exports.addStop = exports.insertStop = exports.uniformScale = exports.uniformStops = exports.reverse = exports.reverseStops = exports.combine = exports.combineColorStops = exports.epsilon = exports.combineStops = exports.length = exports.toArray = exports.toReadonlyArray = exports.changeMode = exports.mode = exports.middle = exports.last = exports.first = exports.stops = exports.stopColor = exports.stopRatio = exports.grayscale = exports.colorScale = exports.colorStops = exports.colorStop = void 0;
/**
 * @since 0.1.0
 */
var Ord = __importStar(require("fp-ts/Ord"));
var number = __importStar(require("fp-ts/number"));
var RA = __importStar(require("fp-ts/ReadonlyArray"));
var A = __importStar(require("fp-ts/Array"));
var O = __importStar(require("fp-ts/Option"));
var boolean = __importStar(require("fp-ts/boolean"));
var string = __importStar(require("fp-ts/string"));
var C = __importStar(require("./Color"));
var function_1 = require("fp-ts/function");
var Foldable_1 = require("fp-ts/Foldable");
var X11_1 = require("./X11");
var UnitInterval_1 = require("./UnitInterval");
var ratio = UnitInterval_1.unitInterval;
/**
 * Create a color stop from a given `Color` and a number between 0 and 1.
 * If the number is outside this range, it is clamped.
 *
 * @category constructors
 * @since 0.1.0
 */
var colorStop = function (c, r) { return [c, ratio(r)]; };
exports.colorStop = colorStop;
/**
 * @category constructors
 * @since 0.1.0
 */
var colorStops = function (l, m, r) {
    return function_1.pipe(m, 
    // clamp color stop ratios
    RA.map(function (_a) {
        var c = _a[0], r = _a[1];
        return exports.colorStop(c, r);
    }), 
    // sort stops by ratio
    RA.sort(OrdColorStop), function (m) { return [l, m, r]; });
};
exports.colorStops = colorStops;
/**
 * Create a color scale. The color space is used for interpolation between
 * different stops. The first `Color` defines the left end (color at ratio
 * 0.0), the list of stops defines possible intermediate steps and the second
 * `Color` argument defines the right end point (color at ratio 1.0).
 *
 * @category constructors
 * @since 0.1.0
 */
var colorScale = function (space, l, m, r) { return ({
    mode: space,
    stops: exports.colorStops(l, m, r)
}); };
exports.colorScale = colorScale;
/**
 * A scale of colors from black to white.
 *
 * @category constructors
 * @since 0.1.0
 */
exports.grayscale = exports.colorScale('RGB', C.black, [], C.white);
/**
 * Extract the ratio out of a ColorStop
 *
 * @category destructors
 * @since 0.1.0
 */
var stopRatio = function (_a) {
    var r = _a[1];
    return r;
};
exports.stopRatio = stopRatio;
/**
 * Extract the color out of a ColorStop
 *
 * @category destructors
 * @since 0.1.0
 */
var stopColor = function (_a) {
    var c = _a[0];
    return c;
};
exports.stopColor = stopColor;
var OrdColorStop = Ord.contramap(exports.stopRatio)(number.Ord);
/**
 * Extract the color out of a ColorStop
 *
 * @category destructors
 * @since 0.1.6
 */
var stops = function (_a) {
    var stops = _a.stops;
    return stops;
};
exports.stops = stops;
/**
 * get the first color of the scale
 *
 * @since 0.1.4
 */
exports.first = function_1.flow(exports.stops, function (_a) {
    var first = _a[0];
    return first;
});
/**
 * get the last color of the scale
 *
 * @since 0.1.4
 */
exports.last = function_1.flow(exports.stops, function (_a) {
    var last = _a[2];
    return last;
});
/**
 * get the middle colors of the scale
 *
 * @since 0.1.4
 * @internal
 */
exports.middle = function_1.flow(exports.stops, function (_a) {
    var middle = _a[1];
    return middle;
});
/**
 * get the `ColorSpace` mode of the scale
 *
 * @since 0.1.4
 */
var mode = function (s) { return s.mode; };
exports.mode = mode;
/**
 * change the `ColorSpace` mode of the scale
 *
 * @since 0.1.4
 */
var changeMode = function (space) {
    return function (_a) {
        var stops = _a.stops;
        return exports.colorScale.apply(void 0, __spreadArray([space], stops));
    };
};
exports.changeMode = changeMode;
/**
 * transform a scale to an ReadonlyArray of ColorStops
 *
 * @category destructors
 * @since 0.1.4
 */
var toReadonlyArray = function (scale) {
    return function_1.pipe(exports.middle(scale), RA.prepend(exports.colorStop(exports.first(scale), 0)), RA.append(exports.colorStop(exports.last(scale), 1)));
};
exports.toReadonlyArray = toReadonlyArray;
/**
 * Use [toReadonlyArray](#toReadonlyArray)
 *
 * @category destructors
 * @since 0.1.0
 * @deprecated
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
exports.toArray = exports.toReadonlyArray;
/**
 * returns the amount of color stops in the scale
 *
 * @category destructors
 * @since 0.1.4
 */
exports.length = function_1.flow(exports.toReadonlyArray, function (x) { return x.length; });
/**
 * Like `combineColorStops`, but the width of the "transition zone" can be specified as the
 * first argument.
 *
 * @example
 *
 * import * as S from 'ts-colors/Scale'
 * import * as X11 from 'ts-colors/X11'
 *
 * const stops = S.colorStops(X11.yellow, [], X11.blue)
 *
 * S.combineStops(0.0005)(0.5)(stops)
 *
 * @since 0.1.0
 */
var combineStops = function (epsilon) {
    return function (x) {
        return function (_a) {
            var aStart = _a[0], aMiddle = _a[1], aEnd = _a[2];
            return function (_a) {
                var bStart = _a[0], bMiddle = _a[1], bEnd = _a[2];
                var startStops = function_1.pipe(aMiddle, RA.map(function (stop) {
                    return function_1.pipe(exports.stopRatio(stop), function (ratio) { return ratio / (1.0 / x); }, function (ratio) { return exports.colorStop(exports.stopColor(stop), ratio); });
                }));
                var midStops = [exports.colorStop(aEnd, x - epsilon), exports.colorStop(bStart, x)];
                var endStops = function_1.pipe(bMiddle, RA.map(function (stop) {
                    return function_1.pipe(exports.stopRatio(stop), function (ratio) { return x + ratio / (1.0 / (1.0 - x)); }, function (ratio) { return exports.colorStop(exports.stopColor(stop), ratio); });
                }));
                var stops = __spreadArray(__spreadArray(__spreadArray([], startStops), midStops), endStops);
                return exports.colorStops(aStart, stops, bEnd);
            };
        };
    };
};
exports.combineStops = combineStops;
/**
 * @internal
 * @since 0.1.4
 */
exports.epsilon = 0.000001;
/**
 * Concatenates two color scales. The first argument specifies the transition point as
 * a number between zero and one. The color right at the transition point is the first
 * color of the second color scale.
 *
 * @example
 *
 * import * as S from 'ts-colors/Scale'
 * import * as X11 from 'ts-colors/X11'
 *
 * const stops = S.colorStops(X11.yellow, [], X11.blue)

 * S.combineColorStops(0.4)(stops)
 *
 * @since 0.1.0
 */
exports.combineColorStops = exports.combineStops(exports.epsilon);
/**
 * Concatenates two color scales. The first argument specifies the transition point as
 * a number between zero and one. The color right at the transition point is the first
 * color of the second color scale.
 *
 * @since 0.1.4
 */
var combine = function (e) { return function (a) { return function (b) {
    var c = exports.combineColorStops(e);
    return function_1.pipe(b.stops, c(a.stops), function (s) { return exports.colorScale.apply(void 0, __spreadArray([a.mode], s)); });
}; }; };
exports.combine = combine;
/**
 * reverses `ColorStops`
 *
 * @since 0.1.0
 * @internal
 */
var reverseStops = function (_a) {
    var start = _a[0], stops = _a[1], end = _a[2];
    return function_1.pipe(stops, RA.reverse, RA.map(function (_a) {
        var c = _a[0], r = _a[1];
        return exports.colorStop(c, 1 - r);
    }), function (stops) { return [end, stops, start]; });
};
exports.reverseStops = reverseStops;
/**
 * Reverses a color scale
 *
 * @since 0.1.4
 */
var reverse = function (_a) {
    var mode = _a.mode, stops = _a.stops;
    return exports.colorScale.apply(void 0, __spreadArray([mode], exports.reverseStops(stops)));
};
exports.reverse = reverse;
/**
 * Create `ColorStops` from a list of colors such that they will be evenly
 * spaced on the scale.
 *
 * @since 0.1.0
 * @internal
 */
var uniformStops = function (s, m, e) {
    var length = m.length;
    var n = 1 + length;
    var stops = A.zipWith(A.range(1, n), m, function (i, c) {
        return exports.colorStop(c, i / n);
    });
    return exports.colorStops(s, stops, e);
};
exports.uniformStops = uniformStops;
/**
 * Create a uniform color scale from a list of colors that will be evenly
 * spaced on the scale.
 *
 * @since 0.1.0
 */
var uniformScale = function (mode) {
    return function (s, m, e) {
        return function_1.pipe(exports.uniformStops(s, m, e), function (stops) { return exports.colorScale.apply(void 0, __spreadArray([mode], stops)); });
    };
};
exports.uniformScale = uniformScale;
var insertBy = function (_a) {
    var compare = _a.compare;
    return function (a) {
        return function (bs) {
            return function_1.pipe(bs, RA.findIndex(function (b) { return compare(a, b) === 1; }), O.fold(function () { return function_1.pipe(bs, RA.append(a)); }, function (i) { return RA.unsafeInsertAt(i, a, bs); }));
        };
    };
};
var insertByRatio = insertBy(OrdColorStop);
/**
 * Add a stop to a list of `ColorStops`.
 *
 * @since 0.1.0
 * @internal
 */
var insertStop = function (c, r) {
    return function (_a) {
        var s = _a[0], m = _a[1], e = _a[2];
        return function_1.pipe(exports.colorStop(c, r), function (stop) { return function_1.pipe(m, insertByRatio(stop)); }, function (stops) { return exports.colorStops(s, RA.toArray(stops), e); });
    };
};
exports.insertStop = insertStop;
/**
 * Add a stop to a color scale.
 *
 * @since 0.1.0
 */
var addStop = function (c, r) {
    return function (_a) {
        var mode = _a.mode, stops = _a.stops;
        return function_1.pipe(stops, exports.insertStop(c, r), function (_a) {
            var s = _a[0], m = _a[1], e = _a[2];
            return exports.colorScale(mode, s, RA.toArray(m), e);
        });
    };
};
exports.addStop = addStop;
var between = Ord.between(number.Ord);
/**
 * Get the color at a specific point on the color scale (number between 0 and
 * 1). If the number is smaller than 0, the color at 0 is returned. If the
 * number is larger than 1, the color at 1 is returned.
 *
 * @since 0.1.0
 * @internal
 */
var simpleSampler = function (interpolate) {
    return function (_a) {
        var start = _a[0], middle = _a[1], end = _a[2];
        return function (x) {
            if (x < 0) {
                return start;
            }
            if (x > 1) {
                return end;
            }
            var sample = function (c1, left, cs) {
                return function_1.pipe(cs, RA.matchLeft(function_1.constant(c1), function (_a, rest) {
                    var c2 = _a[0], right = _a[1];
                    /* istanbul ignore next */
                    if (left === right) {
                        return c1;
                    }
                    return function_1.pipe(x, between(left, right), boolean.fold(function () { return sample(c2, right, rest); }, function () {
                        var p = (x - left) / (right - left);
                        return interpolate(c1)(c2)(p);
                    }));
                }));
            };
            var stops = function_1.pipe(middle, RA.append(exports.colorStop(end, 1.0)));
            return sample(start, 0, stops);
        };
    };
};
exports.simpleSampler = simpleSampler;
/**
 * Get the color at a specific point on the color scale by linearly
 * interpolating between its colors.
 *
 * @since 0.1.0
 */
var sample = function (_a) {
    var mode = _a.mode, stops = _a.stops;
    return function_1.pipe(stops, exports.simpleSampler(C.mix(mode)));
};
exports.sample = sample;
/**
 * Takes a sampling function and returns a list of colors that is sampled via
 * that function. The number of colors can be specified.
 *
 * @since 0.1.0
 * @internal
 */
var makeColors = function (f) {
    return function (n) {
        if (n === 0) {
            return [];
        }
        if (n === 1) {
            return [f(0)];
        }
        return A.makeBy(n, function (i) { return f(i / (n - 1)); });
    };
};
exports.makeColors = makeColors;
/**
 * A list of colors that is sampled from a color scale. The number of colors
 * can be specified.
 *
 * @since 0.1.0
 */
var sampleColors = function (x) {
    return function (scale) {
        return function_1.pipe(x, exports.makeColors(exports.sample(scale)));
    };
};
exports.sampleColors = sampleColors;
/**
 * Modify a list of  `ColorStops` by applying the given function to each color
 * stop. The first argument is the position of the color stop.
 *
 * @since 0.1.0
 * @internal
 */
var modifyColorStops = function (f) {
    return function (_a) {
        var start = _a[0], middle = _a[1], end = _a[2];
        return exports.colorStops(f(0, start), function_1.pipe(middle, RA.map(function (_a) {
            var c = _a[0], r = _a[1];
            return exports.colorStop(f(r, c), r);
        }), RA.toArray), f(1, end));
    };
};
exports.modifyColorStops = modifyColorStops;
/**
 * Modify the colors of a scale by applying the given function to each
 * color stop. The first argument is the position of the color stop.
 *
 * @since 0.1.4
 */
var modify = function (f) {
    return function (_a) {
        var mode = _a.mode, stops = _a.stops;
        return function_1.pipe(stops, exports.modifyColorStops(f), function (stops) { return exports.colorScale.apply(void 0, __spreadArray([mode], stops)); });
    };
};
exports.modify = modify;
/**
 * A spectrum of fully saturated hues (HSL color space).
 *
 * @since 0.1.0
 */
exports.spectrum = function_1.pipe({
    end: C.hsl(0.0, 1.0, 0.5),
    stops: function_1.pipe(A.range(1, 35), A.map(function (i) { return exports.colorStop(C.hsl(10.0 * i, 1.0, 0.5), i / 36.0); }))
}, function (_a) {
    var end = _a.end, stops = _a.stops;
    return exports.colorScale('HSL', end, stops, end);
});
/**
 * A perceptually-uniform, diverging color scale from blue to red, similar to
 * the ColorBrewer scale 'RdBu'.
 *
 * @since 0.1.0
 */
exports.blueToRed = function_1.pipe({
    gray: C.fromInt(0xf7f7f7),
    red: C.fromInt(0xb2182b),
    blue: C.fromInt(0x2166ac)
}, function (_a) {
    var red = _a.red, gray = _a.gray, blue = _a.blue;
    return exports.uniformScale('Lab')(blue, [gray], red);
});
/**
 * A perceptually-uniform, multi-hue color scale from yellow to red, similar
 * to the ColorBrewer scale YlOrRd.
 *
 * @since 0.1.0
 */
exports.yellowToRed = function_1.pipe({
    yellow: C.fromInt(0xffffcc),
    orange: C.fromInt(0xfd8d3c),
    red: C.fromInt(0x800026)
}, function (_a) {
    var yellow = _a.yellow, orange = _a.orange, red = _a.red;
    return exports.uniformScale('Lab')(yellow, [orange], red);
});
/**
 * A color scale that represents 'hot' colors.
 *
 * @since 0.1.0
 */
exports.hot = exports.colorScale('RGB', C.black, [exports.colorStop(X11_1.red, 0.5), exports.colorStop(X11_1.yellow, 0.75)], C.white);
/**
 * A color scale that represents 'cool' colors.
 *
 * @since 0.1.0
 */
exports.cool = exports.colorScale('RGB', C.hsl(180.0, 1.0, 0.6), [], C.hsl(300.0, 1.0, 0.5));
/**
 * Takes number of stops `ColorStops` should contain, function to generate
 * missing colors and `ColorStops` itself.
 *
 * @since 0.1.0
 * @internal
 */
var minColorStops = function (sampler) {
    return function (n) {
        return function (stops) {
            if (n === 0) {
                return stops;
            }
            var additionalStops = function_1.pipe(n > 2, boolean.fold(function_1.constant([]), function () {
                return function_1.pipe(A.range(1, n - 1), A.map(function (step) {
                    var frac = ratio(step / n);
                    return function_1.pipe(frac, sampler(stops), function (c) { return exports.colorStop(c, frac); });
                }));
            }));
            return function_1.pipe(additionalStops, A.reduce(stops, function (stops, _a) {
                var c = _a[0], r = _a[1];
                return function_1.pipe(stops, exports.insertStop(c, r));
            }));
        };
    };
};
exports.minColorStops = minColorStops;
var intercalateAS = Foldable_1.intercalate(string.Monoid, RA.Foldable);
var cssColorStopsRGB = function (_a) {
    var s = _a[0], m = _a[1], e = _a[2];
    if (RA.isEmpty(m)) {
        return C.toHSLAString(s) + ", " + C.toHSLAString(e);
    }
    var percentage = function (r) { return r * 100.0 + "%"; };
    var toString = function (_a) {
        var c = _a[0], r = _a[1];
        return C.toHSLAString(c) + " " + percentage(r);
    };
    var stops = function_1.pipe(m, RA.map(toString), function (stop) { return intercalateAS(', ', stop); });
    return C.toHSLAString(s) + ", " + stops + ", " + C.toHSLAString(e);
};
/**
 * A CSS representation of the color scale in the form of a comma-separated
 * list of color stops. This list can be used in a `linear-gradient` or
 * a similar construct.
 *
 * Note that CSS uses the RGB space for color interpolation. Consequently, if
 * the color scale is in RGB mode, this is just a list of all defined color
 * stops.
 *
 * For other color spaces, the color scale is sampled at (at least) 10
 * different points. This should give a reasonable approximation to the true
 * gradient in the specified color space.
 *
 * @since 0.1.0
 */
var cssColorStops = function (_a) {
    var mode = _a.mode, stops = _a.stops;
    if (mode === 'RGB') {
        return cssColorStopsRGB(stops);
    }
    var interpolate = C.mix(mode);
    var sample = exports.simpleSampler(interpolate);
    var sampleSteps = exports.minColorStops(sample);
    return function_1.pipe(stops, sampleSteps(10), cssColorStopsRGB);
};
exports.cssColorStops = cssColorStops;
//# sourceMappingURL=Scale.js.map