"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.distance = exports.textColor = exports.isReadable = exports.isLight = exports.contrast = exports.luminance = exports.brightness = exports.setAlpha = exports.alpha = exports.mixLab = exports.mixLCh = exports.mixRGB = exports.mixHSL = exports.mix = exports.toGray = exports.desaturate = exports.saturate = exports.darken = exports.lighten = exports.complementary = exports.rotateHue = exports.cssStringRGBA = exports.toRGBAString = exports.cssStringHSLA = exports.toHSLAString = exports.toCSS = exports.toHexString = exports.toLCh = exports.toLab = exports.toXYZ = exports.toHSVA = exports.toHSLA = exports.toRGBA = exports.hue = exports.graytone = exports.white = exports.black = exports.fromInt = exports.fromHexString = exports.lch = exports.lab = exports.xyz = exports.hsv = exports.hsva = exports.rgb2 = exports.rgba2 = exports.rgb = exports.rgba = exports.hsl = exports.hsla = void 0;
exports.Show = exports.OrdBrightness = exports.OrdLuminance = exports.Eq = void 0;
/**
 * @since 0.1.0
 */
var Ord = __importStar(require("fp-ts/Ord"));
var Equals = __importStar(require("fp-ts/Eq"));
var O = __importStar(require("fp-ts/Option"));
var number = __importStar(require("fp-ts/number"));
var Apply_1 = require("fp-ts/Apply");
var function_1 = require("fp-ts/function");
var HSLA = __importStar(require("./HSLA"));
var HSVA = __importStar(require("./HSVA"));
var RGBA = __importStar(require("./RGBA"));
var XYZ = __importStar(require("./XYZ"));
var Lab = __importStar(require("./Lab"));
var LCh = __importStar(require("./LCh"));
var Int = __importStar(require("./Int"));
var math_1 = require("./math");
/**
 * Create a `Color` from Hue, Saturation, Lightness and Alpha values. The
 * Hue is given in degrees, as a `Number` between 0.0 and 360.0. Saturation,
 * Lightness and Alpha are numbers between 0.0 and 1.0.
 *
 * @category constructors
 * @since 0.1.0
 */
exports.hsla = HSLA.hsla;
/**
 * Create a `Color` from Hue, Saturation, Lightness and Alpha values. The
 * Hue is given in degrees, as a `Number` between 0.0 and 360.0. Saturation,
 * Lightness and Alpha are numbers between 0.0 and 1.0.
 *
 * @category constructors
 * @since 0.1.0
 */
var hsl = function (h, s, l) { return exports.hsla(h, s, l, 1); };
exports.hsl = hsl;
/**
 * Create a `Color` from integer RGB values between 0 and 255 and a floating
 * point alpha value between 0.0 and 1.0.
 *
 * RGB to HSL conversion algorithm adapted from
 * https://en.wikipedia.org/wiki/HSL_and_HSV
 *
 * @category constructors
 * @since 0.1.0
 */
exports.rgba = function_1.flow(RGBA.rgba, HSLA.fromRGBA);
/**
 * Create a `Color` from integer RGB values between 0 and 255.
 *
 * @category constructors
 * @since 0.1.0
 */
var rgb = function (r, g, b) { return exports.rgba(r, g, b, 1); };
exports.rgb = rgb;
/**
 * Create a `Color` from RGB and alpha values between 0.0 and 1.0.
 *
 * @category constructors
 * @since 0.1.0
 */
var rgba2 = function (r, g, b, a) {
    return exports.rgba(RGBA.denormalizeChannel(r), RGBA.denormalizeChannel(g), RGBA.denormalizeChannel(b), a);
};
exports.rgba2 = rgba2;
/**
 * Create a `Color` from RGB values between 0.0 and 1.0.
 *
 * @category constructors
 * @since 0.1.0
 */
var rgb2 = function (r, g, b) {
    return exports.rgba2(r, g, b, 1);
};
exports.rgb2 = rgb2;
/**
 * Create a `Color` from Hue, Saturation, Value and Alpha values. The
 * Hue is given in degrees, as a `Number` between 0.0 and 360.0. Saturation,
 * Value and Alpha are numbers between 0.0 and 1.0.
 *
 * @category constructors
 * @since 0.1.0
 */
exports.hsva = function_1.flow(HSVA.hsva, HSLA.fromHSVA);
/**
 * Create a `Color` from Hue, Saturation and Value values. The Hue is
 * given in degrees, as a `Number` between 0.0 and 360.0. Both Saturation and
 * Value are numbers between 0.0 and 1.0.
 *
 * @category constructors
 * @since 0.1.0
 */
var hsv = function (h, s, v) { return exports.hsva(h, s, v, 1); };
exports.hsv = hsv;
/**
 * Create a `Color` from XYZ coordinates in the CIE 1931 color space. Note
 * that a `Color` always represents a color in the sRGB gamut (colors that
 * can be represented on a typical computer screen) while the XYZ color space
 * is bigger. This function will tend to create fully saturated colors at the
 * edge of the sRGB gamut if the coordinates lie outside the sRGB range.
 *
 * See:
 * - https://en.wikipedia.org/wiki/CIE_1931_color_space
 * - https://en.wikipedia.org/wiki/SRGB
 *
 * @category constructors
 * @since 0.1.0
 */
exports.xyz = function_1.flow(XYZ.xyz, HSLA.fromXYZ);
/**
 * Create a `Color` from L, a and b coordinates in the Lab color space.
 * Note: See documentation for `xyz`. The same restrictions apply here.
 *
 * See: https://en.wikipedia.org/wiki/Lab_color_space
 *
 * @category constructors
 * @since 0.1.0
 */
exports.lab = function_1.flow(Lab.lab, HSLA.fromLab);
/**
 * Create a `Color` from lightness, chroma and hue coordinates in the CIE LCh
 * color space. This is a cylindrical transform of the Lab color space.
 * Note: See documentation for `xyz`. The same restrictions apply here.
 *
 * See: https://en.wikipedia.org/wiki/Lab_color_space
 *
 * @category constructors
 * @since 0.1.0
 */
exports.lch = function_1.flow(LCh.lch, HSLA.fromLCh);
var strMatch = function (pattern) { return function (str) {
    return O.fromNullable(str.match(pattern));
}; };
/**
 * Parse a hexadecimal RGB code of the form `#rgb` or `#rrggbb`. The `#`
 * character is required. Each hexadecimal digit is of the form `[0-9a-fA-F]`
 * (case insensitive). Returns `Option.none` if the string is in a wrong format.
 *
 * @category constructors
 * @since 0.1.0
 */
var fromHexString = function (str) {
    var isShort = str.length == 4;
    var digit = '[0-9a-fA-F]';
    var single = "(" + digit + ")";
    var pair = "(" + digit + digit + ")";
    var variant = isShort
        ? "" + single + single + single
        : "" + pair + pair + pair;
    var mPattern = "^#(?:" + variant + ")$";
    var parseHex = Int.fromStringAs(Int.hexadecimal);
    return function_1.pipe(str, strMatch(new RegExp(mPattern)), O.chain(function (groups) {
        return Apply_1.sequenceT(O.Applicative)(parseHex(groups[1]), parseHex(groups[2]), parseHex(groups[3]));
    }), O.map(function (_a) {
        var r = _a[0], g = _a[1], b = _a[2];
        if (isShort) {
            return exports.rgb(16 * r + r, 16 * g + g, 16 * b + b);
        }
        return exports.rgb(r, g, b);
    }));
};
exports.fromHexString = fromHexString;
var clampInt = Ord.clamp(number.Ord)(0, 0xffffff);
/**
 * Converts an integer to a color (RGB representation). `0` is black and
 * `0xffffff` is white. Values outside this range will be clamped.
 *
 * This function is useful if you want to hard-code Hex values. For example:
 *
 * @example
 *
 * import * as C from 'ts-colors/Color'
 *
 * C.fromInt(0xff0000)
 *
 * @category constructors
 * @since 0.1.0
 */
var fromInt = function (i) {
    var n = clampInt(i);
    var r = (n >> 16) & 0xff;
    var g = (n >> 8) & 0xff;
    var b = n & 0xff;
    return exports.rgb(r, g, b);
};
exports.fromInt = fromInt;
/**
 * Pure black.
 *
 * @category constructors
 * @since 0.1.0
 */
exports.black = exports.hsl(0.0, 0.0, 0.0);
/**
 * Pure white.
 *
 * @category constructors
 * @since 0.1.0
 */
exports.white = exports.hsl(0.0, 0.0, 1.0);
/**
 * Create a gray tone from a lightness values (0.0 is black, 1.0 is white).
 *
 * @category constructors
 * @since 0.1.0
 */
var graytone = function (l) { return exports.hsl(0.0, 0.0, l); };
exports.graytone = graytone;
/**
 * Get the color hue in the interval [0, 360].
 *
 * @since 0.1.4
 * @category destructors
 */
var hue = function (_a) {
    var h = _a.h;
    return h;
};
exports.hue = hue;
/**
 * Convert a `Color` to its red, green, blue and alpha values. The RGB values
 * are integers in the range from 0 to 255. The alpha channel is a number
 * between 0.0 and 1.0.
 *
 * @since 0.1.0
 * @category destructors
 */
exports.toRGBA = RGBA.fromHSLA;
/**
 * Convert a `Color` to its Hue, Saturation, Lightness and Alpha values. See
 * `hsla` for the ranges of each channel.
 *
 * @since 0.1.0
 * @category destructors
 */
var toHSLA = function (c) { return c; };
exports.toHSLA = toHSLA;
/**
 * Convert a `Color` to its Hue, Saturation, Value and Alpha values. See
 * `hsva` for the ranges of each channel.
 *
 * @since 0.1.0
 * @category destructors
 */
exports.toHSVA = HSVA.fromHSLA;
/**
 * Get XYZ coordinates according to the CIE 1931 color space.
 *
 * See:
 * - https://en.wikipedia.org/wiki/CIE_1931_color_space
 * - https://en.wikipedia.org/wiki/SRGB
 *
 * @since 0.1.0
 * @category destructors
 */
exports.toXYZ = XYZ.fromHSLA;
/**
 * Get L, a and b coordinates according to the Lab color space.
 *
 * See: https://en.wikipedia.org/wiki/Lab_color_space
 *
 * @since 0.1.0
 * @category destructors
 */
exports.toLab = Lab.fromHSLA;
/**
 * Get L, C and h coordinates according to the CIE LCh color space.
 * See: https://en.wikipedia.org/wiki/Lab_color_space
 *
 * @since 0.1.0
 * @category destructors
 */
exports.toLCh = LCh.fromHSLA;
var hexToString = Int.toStringAs(Int.hexadecimal);
/**
 * @since 0.1.0
 * @category destructors
 */
var toHexString = function (color) {
    var c = exports.toRGBA(color);
    var toHex = function (n) {
        var repr = hexToString(n);
        if (repr.length === 1) {
            return "0" + repr;
        }
        return repr;
    };
    return "#" + toHex(c.r) + toHex(c.g) + toHex(c.b);
};
exports.toHexString = toHexString;
/**
 * A CSS representation of the color
 *
 * @since 0.1.5
 * @category destructors
 */
var toCSS = function (s) { return function (c) {
    switch (s) {
        case 'HSL': {
            return HSLA.toCSS(c);
        }
        case 'Lab':
        case 'LCh':
        case 'RGB': {
            return function_1.pipe(RGBA.fromHSLA(c), RGBA.toCSS);
        }
        default: {
            return function_1.absurd(s);
        }
    }
}; };
exports.toCSS = toCSS;
/**
 * A CSS representation of the color in the form `hsl(..)` or `hsla(...)`.
 *
 * @since 0.1.5
 * @category destructors
 */
exports.toHSLAString = exports.toCSS('HSL');
/**
 * Use [toHSLAString](#toHSLAString) instead
 *
 * @since 0.1.0
 * @category destructors
 * @deprecated
 */
exports.cssStringHSLA = exports.toHSLAString;
/**
 * A CSS representation of the color in the form `rgb(..)` or `rgba(...)`
 *
 * @since 0.1.5
 * @category destructors
 */
exports.toRGBAString = exports.toCSS('RGB');
/**
 * Use [toRGBAString](#toRGBAString) instead
 *
 * @since 0.1.0
 * @category destructors
 * @deprecated
 */
exports.cssStringRGBA = exports.toRGBAString;
/**
 * Rotate the hue of a `Color` by a certain angle (in degrees).
 *
 * @since 0.1.0
 */
exports.rotateHue = HSLA.rotateHue;
/**
 * Get the complementary color (hue rotated by 180°).
 *
 * @since 0.1.0
 */
exports.complementary = exports.rotateHue(180);
/**
 * Lighten a color by adding a certain amount (number between -1.0 and 1.0)
 * to the lightness channel. If the number is negative, the color is
 * darkened.
 *
 * @since 0.1.0
 */
var lighten = function (f) {
    return function (_a) {
        var h = _a.h, s = _a.s, l = _a.l, a = _a.a;
        return exports.hsla(h, s, l + f, a);
    };
};
exports.lighten = lighten;
/**
 * Darken a color by subtracting a certain amount (number between -1.0 and
 * 1.0) from the lightness channel. If the number is negative, the color is
 * lightened.
 *
 * @since 0.1.0
 */
var darken = function (f) { return exports.lighten(-f); };
exports.darken = darken;
/**
 * Increase the saturation of a color by adding a certain amount (number
 * between -1.0 and 1.0) to the saturation channel. If the number is
 * negative, the color is desaturated.
 *
 * @since 0.1.0
 */
var saturate = function (f) {
    return function (_a) {
        var h = _a.h, s = _a.s, l = _a.l, a = _a.a;
        return exports.hsla(h, s + f, l, a);
    };
};
exports.saturate = saturate;
/**
 * Decrease the saturation of a color by subtracting a certain amount (number
 * between -1.0 and 1.0) from the saturation channel. If the number is
 * negative, the color is saturated.
 *
 * @since 0.1.0
 */
var desaturate = function (f) { return exports.saturate(-f); };
exports.desaturate = desaturate;
/**
 * Convert a color to a gray tone with the same perceived luminance (see [luminance](#luminance))
 *
 * @since 0.1.0
 */
var toGray = function (c) {
    return function_1.pipe(exports.toLCh(c), function (c) { return exports.lch(c.l, 0.0, 0.0); }, exports.desaturate(1));
};
exports.toGray = toGray;
/**
 * Mix two colors by linearly interpolating between them in the RGB color space.
 *
 * @since 0.1.0
 */
var mix = function (space) { return function (a) { return function (b) { return function (r) {
    switch (space) {
        case 'HSL': {
            return HSLA.mix(r)(a)(b);
        }
        case 'RGB': {
            var f = exports.toRGBA(a);
            var t = exports.toRGBA(b);
            return function_1.pipe(RGBA.mix(r)(f)(t), HSLA.fromRGBA);
        }
        case 'LCh': {
            var f = exports.toLCh(a);
            var t = exports.toLCh(b);
            return function_1.pipe(LCh.mix(r)(f)(t), HSLA.fromLCh);
        }
        case 'Lab': {
            var f = exports.toLab(a);
            var t = exports.toLab(b);
            return function_1.pipe(Lab.mix(r)(f)(t), HSLA.fromLab);
        }
    }
}; }; }; };
exports.mix = mix;
/**
 * Mix two colors by linearly interpolating between them in the  HSL colorspace.
 * The shortest path is chosen along the circle of hue values.
 *
 * @since 0.1.0
 */
exports.mixHSL = exports.mix('HSL');
/**
 * Mix two colors by linearly interpolating between them in the RGB color space.
 *
 * @since 0.1.0
 */
exports.mixRGB = exports.mix('RGB');
/**
 * Mix two colors by linearly interpolating between them in the LCh color space.
 *
 * @since 0.1.0
 */
exports.mixLCh = exports.mix('LCh');
/**
 * Mix two colors by linearly interpolating between them in the Lab color space.
 *
 * @since 0.1.0
 */
exports.mixLab = exports.mix('Lab');
/**
 * get the alpha channel of a color
 *
 * @since 0.1.7
 */
exports.alpha = HSLA.alpha;
/**
 * get the alpha channel of a color
 *
 * @since 0.1.7
 */
exports.setAlpha = HSLA.setAlpha;
/**
 * The percieved brightness of the color (A number between 0.0 and 1.0).
 * See: https://www.w3.org/TR/AERT#color-contrast
 *
 * @since 0.1.0
 */
exports.brightness = function_1.flow(RGBA.normalizedFromHSLA, RGBA.brightness);
/**
 * The relative brightness of a color (normalized to 0.0 for darkest black
 * and 1.0 for lightest white), according to the WCAG definition.
 *
 * See: https://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
 *
 * @since 0.1.0
 */
exports.luminance = function_1.flow(RGBA.normalizedFromHSLA, RGBA.luminance);
/**
 * The contrast ratio of two colors. A minimum contrast ratio of 4.5 is
 * recommended to ensure that text is readable on a colored background. The
 * contrast ratio is symmetric on both arguments:
 * `contrast c1 c2 == contrast c2 c1`.
 *
 * See http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef
 *
 * @since 0.1.0
 */
var contrast = function (c1) {
    return function (c2) {
        var o = 0.05;
        var l1 = exports.luminance(c1);
        var l2 = exports.luminance(c2);
        return l1 > l2 ? (l1 + o) / (l2 + o) : (l2 + o) / (l1 + o);
    };
};
exports.contrast = contrast;
/**
 * Determine whether a color is perceived as a light color.
 *
 * @since 0.1.0
 */
var isLight = function (c) { return exports.brightness(c) > 0.5; };
exports.isLight = isLight;
/**
 * Determine whether text of one color is readable on a background of a
 * different color (see `contrast`). This function is symmetric in both
 * arguments.
 *
 * @since 0.1.0
 */
var isReadable = function (c1) {
    return function (c2) {
        return function_1.pipe(c2, exports.contrast(c1), function (c) { return c > 4.5; });
    };
};
exports.isReadable = isReadable;
/**
 * Return a readable foreground text color (either `black` or `white`) for a
 * given background color.
 *
 * @since 0.1.0
 */
var textColor = function (c) { return (exports.isLight(c) ? exports.black : exports.white); };
exports.textColor = textColor;
/**
 * Compute the perceived 'distance' between two colors according to the CIE76
 * delta-E standard. A distance below ~2.3 is not noticable.
 *
 * See: https://en.wikipedia.org/wiki/Color_difference
 *
 * @since 0.1.0
 */
var distance = function (a) {
    return function (b) {
        var ca = exports.toLab(a);
        var cb = exports.toLab(b);
        return Math.sqrt(math_1.square(ca.l - cb.l) + math_1.square(ca.a - cb.a) + math_1.square(ca.b - cb.b));
    };
};
exports.distance = distance;
/**
 * @category instances
 * @since 0.1.0
 *
 * - The `Eq` instance compares two `Color`s by comparing their (integer) RGB
 *   values. This is different from comparing the HSL values (for example,
 *   HSL has many different representations of black (arbitrary hue and
 *   saturation values).
 */
exports.Eq = Equals.contramap(exports.toRGBA)(RGBA.Eq);
/**
 * @category instances
 * @since 0.1.0
 */
exports.OrdLuminance = Ord.contramap(exports.luminance)(number.Ord);
/**
 * @category instances
 * @since 0.1.4
 */
exports.OrdBrightness = Ord.contramap(exports.brightness)(number.Ord);
/**
 * @category instances
 * @since 0.1.0
 */
exports.Show = {
    show: function (c) { return function_1.pipe(exports.toRGBA(c), RGBA.Show.show); }
};
//# sourceMappingURL=Color.js.map