"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.overlay = exports.screen = exports.multiply = exports.blend = exports.blendChannel = void 0;
/**
 * @since 0.1.0
 */
var function_1 = require("fp-ts/function");
var Color_1 = require("./Color");
var RGBA_1 = require("./RGBA");
/**
 * Blend two RGB channel values (numbers between 0.0 and 1.0).
 *
 * @internal
 * @since 0.1.0
 */
var blendChannel = function (mode) {
    return function (a) {
        return function (b) {
            switch (mode) {
                case 'multiply': {
                    return a * b;
                }
                case 'screen': {
                    return 1.0 - (1.0 - a) * (1.0 - b);
                }
                case 'overlay': {
                    if (a < 0.5) {
                        return 2.0 * (a * b);
                    }
                    return 1.0 - 2.0 * (1.0 - a) * (1.0 - b);
                }
                default: {
                    return function_1.absurd(mode);
                }
            }
        };
    };
};
exports.blendChannel = blendChannel;
/**
 * Blend two colors with a specified blend mode. The first color is the
 * background color, the second one is the foreground color. The resulting
 * alpha value is calculated as arithmetic mean.
 *
 * @since 0.1.0
 */
var blend = function (mode) {
    return function (a) {
        return function (b) {
            var ac = RGBA_1.normalizedFromHSLA(a);
            var bc = RGBA_1.normalizedFromHSLA(b);
            var bcm = exports.blendChannel(mode);
            return Color_1.rgba2(bcm(ac.r)(bc.r), bcm(ac.g)(bc.g), bcm(ac.b)(bc.b), (ac.a + bc.a) / 2.0);
        };
    };
};
exports.blend = blend;
/**
 * @since 0.1.0
 */
exports.multiply = exports.blend('multiply');
/**
 * @since 0.1.0
 */
exports.screen = exports.blend('screen');
/**
 * @since 0.1.0
 */
exports.overlay = exports.blend('overlay');
//# sourceMappingURL=Blending.js.map